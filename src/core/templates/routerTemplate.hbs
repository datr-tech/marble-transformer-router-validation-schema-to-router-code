/**
 * @module api/routers/{{ modelPrefix }}Router
 */
import { {{ controllerName }} } from '{{ appRef }}/api/controllers/{{ controllerDirName }}';
import { {{ controllerInterfaceName }}OutputError } from '{{ appRef }}/interfaces/api/controllers/{{ controllerInterfaceName }}OutputError';
import { {{ controllerInterfaceName }}OutputSuccess } from '{{ appRef }}/interfaces/api/controllers/{{ controllerInterfaceName }}OutputError';
import { {{ modelInterfaceName }} } from '{{ appRef }}/interfaces/api/models/{{ modelInterfaceName }}';
import { {{ routerInterfaceName }} } from '{{ appRef }}/interfaces/api/routers/{{ routerInterfaceName }}';
import { {{ routerValidationSchemaName }} } from '@datr.tech/cargo-router-validation-schemas-{{ apiShortName }}';
import { options } from '@datr.tech/leith-config-api-router-options';
import { Request, Response, Router } from 'express';
import {
  checkExact,
  checkSchema,
  matchedData,
  Schema,
  validationResult,
} from 'express-validator';

/**
 * @name					{{ routerName }}
 *
 * @description		The '{{ controllerMethodName }}' router for '{{ modelPrefix }}',
 *                whose expected inputs have been defined within the following schema:
 *                '{{ routerValidationSchemaName }}',
 *                
 *                The schema will be used by 'express-validator' to perform input validation.
 *                When the validation process succeeds, control will pass to the associated controller,
 *                '{{ controllerName }}', which, when successful, returns a common status (or 'stat') object,
 *                whose 'payload' will contain '{{ controllerOnSuccessVariableName }}'.
 *
 * @param					{Request}		req		The Express request.
 * @param         {Response}	res		The Express response.
 * @return				{undefined}
 *
 * @author				Datr.Tech Admin <admin@datr.tech>
 * @version				0.3.2
 */
export const {{ routerName }}: {{ routerInterfaceName }} = Router(options).{{ httpMethodName }}(
  '/',
  checkSchema(<Schema>{{ routerValidationSchemaName }}),
  checkExact(),
  async (req: Request, res: Response) => {
    const errors = validationResult(req);

		try {
			/*
       * Handle validation errors in relation to the fields
       * defined within '{{ routerValidationSchemaName }}'.
       * In addition, and because of the inclusion of 'checkExact()'
       * above, ONLY fields defined within the schema will be accepted.
       */
			if (!errors.isEmpty()) {
				res.status(422).send({ error: errors.array() });
			}
	
			/*
       * On validation success, pass the 'validatedParams' object to '{{ controllerName }}. 
       */
			const validatedParams = matchedData<{{ modelInterfaceName }}>(req);
			const stat = await {{ controllerName }}.{{ controllerMethodName }}(validatedParams);

			/*
       * If the common controller response object, 'stat', is not truthy, or if
       * 'stat.error' is positive, then handle the error returned by the controller.
       */
			if (!stat || stat.error) {
				const { message, responseStatusCode } = (stat as {{ controllerInterfaceName }}OutputError).payload;
				res.status(responseStatusCode).send({ error: message });
			}

		  /*
       * If the controller call proved to be successful, extract
       * '{{ controllerOnSuccessVariableName }}' from 'stat.payload'
       * and return it with an appropriate status code.
       */
			const { {{ controllerOnSuccessVariableName }}, responseStatusCode } = (stat as {{ controllerInterfaceName }}OutputSuccess).payload;
			res.status( {{ responseStatusCode }}).send({ {{ controllerOnSuccessVariableName }} });
		} catch(error) {

      /*
       * Handle any errors not caught above. 
       */
			const { message } = error;
			res.status(500).send({ error: message });
		}
  },
);
