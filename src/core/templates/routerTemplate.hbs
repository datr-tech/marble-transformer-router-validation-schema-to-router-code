/**
 * @module api/routers/{{ modelPrefix }}Router
 */
import { Request, Response, Router } from 'express';
import { checkExact, checkSchema, matchedData, Schema, validationResult } from 'express-validator';
import { {{ routerValidationSchemaName }} } from '@datr.tech/cargo-router-validation-schemas-{{ apiName }}';
import { options } from '@datr.tech/leith-config-api-router-options';
import { {{ controllerName }} } from '{{ appRef }}/api/controllers/{{ controllerDirName }}';
import { {{ modelInterfaceName }} } from '{{ appRef }}/interfaces/api/models/{{ modelInterfaceName }}';
import { {{ controllerInterfaceName }}OutputError as IControllerError, {{ controllerInterfaceName }}OutputSuccess as IControllerSuccess } from '{{ appRef }}/interfaces/api/controllers';

/**
 * @name					{{ routerName }}
 *
 * @description		The '{{ controllerMethodName }}' router for '{{ modelPrefix }}', whose expected
 *                inputs have been defined within the following schema:
 *                '{{ routerValidationSchemaName }}'.
 *                
 *                The schema will be used by 'express-validator' to perform input validation.
 *                When the validation process succeeds, control will pass to the associated
 *                controller, '{{ controllerName }}', which, when successful, will return
 *                a common status (or 'stat') object, whose 'payload' will contain
 *                '{{ controllerOnSuccessVariableName }}'.
 *
 * @param					{Request}		req		The Express request.
 * @param         {Response}	res		The Express response.
 * @return				{undefined}
 *
 * @author				Datr.Tech Admin <admin@datr.tech>
 * @version				0.3.2
 */
export const {{ routerName }} = Router(options).{{ httpMethodName }}(
  '/',
  checkSchema(<Schema>{{ routerValidationSchemaName }}),
  checkExact(),
  async (req: Request, res: Response) => {
    const errors = validationResult(req);

		try {
			/*
       * Handle validation errors
       * ------------------------
       *
       * Handle validation errors in relation to the fields
       * defined within '{{ routerValidationSchemaName }}'.
       * Additionally, and because of the inclusion of 'checkExact()'
       * above, ONLY fields defined within the schema will be accepted.
       */
			if (!errors.isEmpty()) {
				res.status(422).send({ error: errors.array() });
			}
	
			/*
       * Pass the validated params to the controller
       * -------------------------------------------
       *
       * On validation success, retrieve the 'validatedParams' object
       * from the received 'req' (using 'matchedData') and pass them
       * to '{{ controllerName }}'. 
       */
			const validatedParams = matchedData<{{ modelInterfaceName }}>(req);
			const stat = await {{ controllerDirName }}.{{ controllerMethodName }}(validatedParams);

			/*
       * Handle controller errors
       * ------------------------
       *
       * If the common controller response object, 'stat', is not truthy, or if
       * 'stat.error' equals true, then handle the error returned by the controller.
       */
			if (!stat || stat.error) {
				const { message, responseStatusCode } = (stat as IControllerError).payload;
				res.status(responseStatusCode).send({ error: message });
			}

		  /*
       * Handle successful controller responses
       * --------------------------------------
       *
       * If the controller call proved to be successful, extract
       * '{{ controllerOnSuccessVariableName }}' from 'stat.payload' and return
       * it with an appropriate status code.
       */
			const { {{ controllerOnSuccessVariableName }}, responseStatusCode } = (stat as IControllerSuccess).payload;
			res.status(responseStatusCode).send({ {{ controllerOnSuccessVariableName }} });
		} catch(error) {

      /*
       * Handle any errors not caught above. 
       */
			const { message } = error;
			res.status(500).send({ error: message });
		}
  },
);
